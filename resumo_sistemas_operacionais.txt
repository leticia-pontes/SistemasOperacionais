Resumo de Sistemas Operacionais ‚Äì Concorr√™ncia e Ger√™ncia de Mem√≥ria

1. MUTEX (Exclus√£o M√∫tua)
- Objetivo: Garantir que apenas uma thread acesse uma se√ß√£o cr√≠tica por vez.
- Vari√°veis compartilhadas podem causar condi√ß√£o de corrida (race condition), onde o resultado depende da ordem de execu√ß√£o.
- Mutex √© uma trava bin√°ria usada para proteger se√ß√µes cr√≠ticas.
- Exemplo em Python:

import threading

mutex = threading.Lock()
saldo = 100

def sacar(valor):
    global saldo
    with mutex:
        if saldo >= valor:
            saldo -= valor

- O uso de "with mutex" em Python √© equivalente a adquirir e liberar o lock de forma segura.

2. CONDI√á√ÉO DE CORRIDA (Lock vs NoLock)
- NoLock: V√°rias threads acessam recursos compartilhados sem controle, levando a erros imprevis√≠veis.
- Lock: Threads usam mutex para garantir acesso exclusivo, evitando inconsist√™ncia.
- Condi√ß√µes de corrida s√£o erros dif√≠ceis de reproduzir e depurar.

# LOCK
import threading
import time

contador = 0
lock = threading.Lock()

def incrementar(nome_thread):
    global contador
    for _ in range(100000):
        time.sleep(0.00001)
        with lock:
            contador += 1
    print(f"Thread {nome_thread} terminou.")

def main():
    global contador
    contador = 0

    thread1 = threading.Thread(target=incrementar, args=("A",))
    thread2 = threading.Thread(target=incrementar, args=("B",))

    print("Executando vers√£o COM LOCK...")
    inicio = time.time()

    thread1.start()
    thread2.start()

    thread1.join()
    thread2.join()

    fim = time.time()
    print(f"\n[COM LOCK] Valor final do contador: {contador}")
    print(f"Tempo total: {fim - inicio:.4f} segundos\n")

if __name__ == "__main__":
    main()

Com Lock
*  Valor final do contador	: Sempre correto (200000)
*  Seguran√ßa da concorr√™ncia	: ‚úÖ Protegido por exclus√£o m√∫tua
*  Facilidade de depura√ß√£o	: F√°cil de validar
*  Velocidade : Mais lenta, por√©m segura

# NO LOCK
import threading
import time

contador = 0

def incrementar(nome_thread):
    global contador
    for _ in range(100000):
        atual = contador
        time.sleep(0.00001)  # Atraso proposital para simular disputa
        contador = atual + 1
    print(f"Thread {nome_thread} terminou.")

def main():
    global contador
    contador = 0

    thread1 = threading.Thread(target=incrementar, args=("A",))
    thread2 = threading.Thread(target=incrementar, args=("B",))

    print("Executando vers√£o SEM LOCK...")
    inicio = time.time()

    thread1.start()
    thread2.start()

    thread1.join()
    thread2.join()

    fim = time.time()
    print(f"\n[SEM LOCK] Valor final do contador: {contador}")
    print(f"Tempo total: {fim - inicio:.4f} segundos\n")

if __name__ == "__main__":
    main()

Sem Lock

*  Valor final do contador	: Vari√°vel (frequentemente errado)
*  Seguran√ßa da concorr√™ncia	: ‚ùå Vulner√°vel a race conditions
*  Facilidade de depura√ß√£o	: Dif√≠cil (bugs intermitentes)
*  Velocidade : Pode ser ligeiramente mais r√°pida, mas com erros


3. SEM√ÅFORO
- Um sem√°foro √© uma vari√°vel especial usada para controlar o acesso a m√∫ltiplos recursos.
- Pode ser bin√°rio (0 ou 1) ou cont√°vel (>1).
- Opera√ß√µes b√°sicas:
  - acquire() ‚Üí decrementa o contador ou bloqueia se for 0
  - release() ‚Üí incrementa o contador e desbloqueia uma thread

üîµ Sem√°foro (√† esquerda):
Permite at√© 3 threads ao mesmo tempo usando o recurso.

As marca√ß√µes (bolinhas) mostram v√°rias threads diferentes acessando em paralelo.

Esse comportamento √© ideal quando temos v√°rios recursos dispon√≠veis, como:

Vagas de conex√£o a banco de dados.

Impressoras dispon√≠veis.

M√°quinas em uma fila de produ√ß√£o.

üî¥ Lock (√† direita):
Apenas uma thread por vez consegue acessar o recurso.

O acesso √© completamente sequencial.

Bom para prote√ß√£o total, mas ineficiente se voc√™ tiver m√∫ltiplos recursos e usar lock como se fosse um √∫nico gargalo.

üìö Conclus√£o Did√°tica:

Apenas um recurso deve ser usado por vez:	Lock
V√°rios recursos iguais (ex: 3 impressoras):	Semaphore(n)
Controle total e simples:	Lock
Controle mais flex√≠vel:	Semaphore

- Exemplo em Python:

import threading

sem = threading.Semaphore(3)  # permite at√© 3 threads simult√¢neas

def tarefa():
    with sem:
        # se√ß√£o cr√≠tica

- Sem√°foros s√£o √∫teis quando h√° m√∫ltiplos recursos (ex: conex√µes, impressoras, etc.)

import threading
import time
import matplotlib.pyplot as plt

# N√∫mero m√°ximo de threads que podem acessar simultaneamente
MAX_RECURSOS = 3

# Sem√°foro permitindo at√© MAX_RECURSOS threads
semaforo = threading.Semaphore(MAX_RECURSOS)

# Lock tradicional (exclus√£o total)
lock = threading.Lock()

# Registros para visualiza√ß√£o
acessos_com_semaforo = []
acessos_com_lock = []

# Fun√ß√£o simulando acesso a um recurso limitado
def acessar_recurso_com_semaforo(thread_id):
    for _ in range(3):
        #semaforo.acquire()
        with semaforo:
          acessos_com_semaforo.append((thread_id, time.time()))
          time.sleep(0.5)  # Simula tempo de uso do recurso
        #semaforo.release()

# Fun√ß√£o simulando acesso ao mesmo recurso com lock (exclusivo)
def acessar_recurso_com_lock(thread_id):
    for _ in range(3):
        #lock.acquire()
        with lock:
          acessos_com_lock.append((thread_id, time.time()))
          time.sleep(0.5)
        #lock.release()

# Criar e executar threads para ambos os casos
def simular_acessos():
    threads_semaforo = [threading.Thread(target=acessar_recurso_com_semaforo, args=(i,)) for i in range(6)]
    threads_lock = [threading.Thread(target=acessar_recurso_com_lock, args=(i,)) for i in range(6)]

    # Iniciar com sem√°foro
    for t in threads_semaforo:
        t.start()
    for t in threads_semaforo:
        t.join()

    # Iniciar com lock
    for t in threads_lock:
        t.start()
    for t in threads_lock:
        t.join()

# Executar simula√ß√£o
simular_acessos()

# Preparar dados para o gr√°fico
tempos_s, ids_s = zip(*acessos_com_semaforo)
tempos_l, ids_l = zip(*acessos_com_lock)

# Plotar
plt.figure(figsize=(14, 6))

# Sem√°foro
plt.subplot(1, 2, 1)
plt.scatter(tempos_s, ids_s, c='blue')
plt.title("Acessos com Sem√°foro (3 simult√¢neos)")
plt.xlabel("Tempo")
plt.ylabel("ID da Thread")
plt.grid(True)

# Lock
plt.subplot(1, 2, 2)
plt.scatter(tempos_l, ids_l, c='red')
plt.title("Acessos com Lock (1 por vez)")
plt.xlabel("Tempo")
plt.ylabel("ID da Thread")
plt.grid(True)

plt.tight_layout()
plt.show()


4. JANTAR DOS FIL√ìSOFOS
- Problema cl√°ssico de concorr√™ncia: 5 fil√≥sofos precisam de 2 garfos (esquerda e direita) para comer.
- Deadlock ocorre se todos pegarem um garfo e esperarem o segundo.

from enum import Enum
import threading
import time
import random

NUM_FILOSOFOS = 5
TEMPO_PARA_COMER = 1
NUM_CICLOS = 5 # N√∫mero de vezes que o ciclo "Pensar, Com Fome, Comer" √© realizado

semaforo = threading.Semaphore(NUM_FILOSOFOS - 1)

garfos = [threading.Lock() for _ in range(NUM_FILOSOFOS)]

class FilosofoState(Enum):
    PENSANDO = "pensando"
    COM_FOME = "com fome"
    COMENDO = "comendo"

class Filosofo(threading.Thread):
    def __init__(self, tid):
        super().__init__()
        self.tid = tid
        self.state = FilosofoState.PENSANDO

    def run(self):
        self.ciclo()

    def pensar(self):
        self.state = FilosofoState.PENSANDO
        print(f"Fil√≥sofo {self.tid} est√° pensando.")
        time.sleep(random.uniform(0.5, 1.5))

    def pegar_garfos(self):
        self.state = FilosofoState.COM_FOME
        print(f"Fil√≥sofo {self.tid} est√° com fome.")
        semaforo.acquire()

        garfo_esquerdo = garfos[self.tid]
        garfo_direito = garfos[(self.tid + 1) % NUM_FILOSOFOS]

        primeiro, segundo = (garfo_esquerdo, garfo_direito) if self.tid % 2 == 0 else (garfo_direito, garfo_esquerdo)

        primeiro.acquire()
        segundo.acquire()

    def soltar_garfos(self):
        garfos[self.tid].release()
        garfos[(self.tid + 1) % NUM_FILOSOFOS].release()
        semaforo.release()

    def comer(self):
        self.state = FilosofoState.COMENDO
        print(f"Fil√≥sofo {self.tid} est√° comendo.")
        time.sleep(TEMPO_PARA_COMER)

    def ciclo(self):
        for _ in range(NUM_CICLOS):
            self.pensar()
            self.pegar_garfos()
            self.comer()
            self.soltar_garfos()

def main():
    filosofos = [Filosofo(i) for i in range(NUM_FILOSOFOS)]

    for f in filosofos:
        f.start()

    for f in filosofos:
        f.join()

    print("Todos os fil√≥sofos terminaram seus ciclos.")

if __name__ == "__main__":
    main()

a) Com Locks:
- Cada fil√≥sofo tenta pegar os dois locks (garfos).
- Se todos fizerem isso ao mesmo tempo, o sistema entra em deadlock.

import threading  # Biblioteca de threads
import time       # Para pausas temporais
import random     # Para gerar tempos aleat√≥rios

N = 5  # N√∫mero de fil√≥sofos (e garfos)

# Cria uma lista de locks (um por garfo)
garfos = [threading.Lock() for _ in range(N)]

# Fun√ß√£o com o comportamento de cada fil√≥sofo
def filosofo(i):
    esquerda = garfos[i]               # Garfo √† esquerda do fil√≥sofo i
    direita = garfos[(i + 1) % N]      # Garfo √† direita (com wrap-around)

    while True:
        print(f"Fil√≥sofo {i} est√° pensando...")  # Estado: pensando
        time.sleep(random.uniform(0.5, 1.5))     # Espera um tempo aleat√≥rio
        print(f"Fil√≥sofo {i} est√° com fome.")    # Estado: com fome

        # Define a ordem de pegar os garfos para evitar deadlock
        # Fil√≥sofos pares pegam esquerda depois direita; √≠mpares fazem o oposto
        primeiro, segundo = (esquerda, direita) if i % 2 == 0 else (direita, esquerda)

        # Tenta pegar os dois garfos com `with`, que faz o acquire/release autom√°tico
        with primeiro:
            with segundo:
                print(f"Fil√≥sofo {i} est√° comendo.")  # Estado: comendo
                time.sleep(random.uniform(0.5, 1.5))  # Come por um tempo aleat√≥rio
                print(f"Fil√≥sofo {i} terminou de comer.")  # Termina de comer

# Cria e inicia as threads dos fil√≥sofos
for i in range(N):
    threading.Thread(target=filosofo, args=(i,), daemon=True).start()

time.sleep(10)  # Executa por 10 segundos antes de encerrar o programa


b) Com Sem√°foro:
- Usa-se um sem√°foro para limitar o n√∫mero de fil√≥sofos que tentam comer ao mesmo tempo.
- Ex: sem = threading.Semaphore(4) permite at√© 4 tentarem comer, evitando o deadlock.

#%%
import threading  # Importa a biblioteca para trabalhar com threads
import time       # Para adicionar pausas (sleep)
import random     # Para gerar tempos aleat√≥rios

N = 5  # N√∫mero de fil√≥sofos (e garfos)

# Cria uma lista de sem√°foros, um para cada garfo
semaforos = [threading.Semaphore(1) for _ in range(N)]

# Fun√ß√£o que representa o comportamento de cada fil√≥sofo
def filosofo(i):
    while True:
        print(f"Fil√≥sofo {i} est√° pensando...")  # Estado: pensando
        time.sleep(random.uniform(0.5, 1.5))    # Espera um tempo aleat√≥rio
        print(f"Fil√≥sofo {i} est√° com fome.")   # Estado: com fome
        semaforos[i].acquire()                 # Pega o garfo √† esquerda
        semaforos[(i + 1) % N].acquire()       # Pega o garfo √† direita (com wrap-around)
        print(f"Fil√≥sofo {i} est√° comendo.")    # Estado: comendo
        time.sleep(random.uniform(0.5, 1.5))    # Come por um tempo aleat√≥rio
        print(f"Fil√≥sofo {i} terminou de comer.")  # Termina de comer
        semaforos[i].release()                 # Solta o garfo √† esquerda
        semaforos[(i + 1) % N].release()       # Solta o garfo √† direita

# Cria e inicia uma thread para cada fil√≥sofo
for i in range(N):
    threading.Thread(target=filosofo, args=(i,), daemon=True).start()

time.sleep(10)  # Executa o programa por 10 segundos antes de encerrar


5. GERENCIAMENTO DE MEM√ìRIA
- Algoritmos para alocar espa√ßo na mem√≥ria:

a) First Fit:
- Encontra a primeira parti√ß√£o livre que seja grande o suficiente.
- R√°pido, mas pode causar fragmenta√ß√£o externa.

b) Best Fit:
- Escolhe a menor parti√ß√£o livre que seja suficiente.
- Minimiza o espa√ßo desperdi√ßado, mas pode deixar muitos blocos pequenos e inutiliz√°veis.

c) Worst Fit:
- Escolhe a maior parti√ß√£o livre.
- Deixa espa√ßos grandes restantes, mas pode desperdi√ßar mem√≥ria.

First fit: √© mais r√°pido, uma vez que encerra a busca por mem√≥ria dispon√≠vel assim que encontra espa√ßo suficiente para o processo. Por√©m, por esse mesmo motivo (encaixar no primeiro espa√ßo dispon√≠vel), pode levar mais tempo para executar v√°rios processos, uma vez que, ao alocar um bloco de mem√≥ria, possivelmente haver√° desperd√≠cio de mem√≥ria, restando v√°rios fragmentos menores de mem√≥ria inutilizada. Com isso, eventualmente, pode n√£o haver espa√ßo para alocar alguns processos, precisando de m√©todos para contornar essa situa√ß√£o. √â bom para casos onde o tempo √© um fator crucial na execu√ß√£o nos processos.

Best fit: √© mais lento que o first fit, porque passa por todos os blocos dispon√≠veis para verificar qual bloco que, ao ser alocado, ter√° o menor desperd√≠cio. Por esse motivo, a chance de algum processo n√£o ser alocado √© menor. Por√©m, por conseguir alocar todos mais facilmente, as unidades de mem√≥ria dispon√≠veis s√£o menores. Caso a quantidade de mem√≥ria dispon√≠vel/reservada seja importante para o programa/sistema, o best fit pode n√£o ser a melhor escolha.

Worst fit: tenta alocar o processo no maior bloco de mem√≥ria dispon√≠vel, ou seja, aquele que deixar√° o maior espa√ßo livre restante ap√≥s a aloca√ß√£o. A ideia por tr√°s dessa estrat√©gia √© evitar a fragmenta√ß√£o externa, j√° que grandes blocos restantes podem ser mais √∫teis futuramente do que pequenos fragmentos. No entanto, o worst fit tende a gerar muita fragmenta√ß√£o interna, pois frequentemente grandes blocos s√£o subdivididos mesmo quando processos pequenos s√£o alocados. Al√©m disso, √© o mais demorado dos tr√™s m√©todos, pois precisa analisar todos os blocos para encontrar o maior. Pode ser √∫til em situa√ß√µes em que se deseja preservar blocos m√©dios ou pequenos para processos futuros de menor porte, mas, na pr√°tica, raramente oferece desempenho superior ao first fit ou best fit.


- Fragmenta√ß√£o externa: espa√ßos livres pequenos espalhados pela mem√≥ria que n√£o podem ser usados.

import copy  # Importa o m√≥dulo copy para fazer c√≥pias independentes de listas

# Fun√ß√£o que implementa o algoritmo First Fit
def first_fit(memory_blocks, processes):
    allocation = [-1] * len(processes)  # Lista para armazenar em qual bloco cada processo foi alocado (-1 = n√£o alocado)
    waste = [0] * len(processes)        # Lista para registrar o desperd√≠cio (fragmenta√ß√£o interna) por processo

    for i, process in enumerate(processes):  # Para cada processo
        for j, block in enumerate(memory_blocks):  # Para cada bloco de mem√≥ria
            if block >= process:  # Verifica se o bloco √© suficientemente grande para o processo
                allocation[i] = j  # Registra a aloca√ß√£o do processo no bloco j
                waste[i] = memory_blocks[j] - process  # Calcula a fragmenta√ß√£o interna (espa√ßo sobrando)
                memory_blocks[j] -= process  # Atualiza o bloco, subtraindo o tamanho do processo
                break  # Para ap√≥s encontrar o primeiro bloco adequado (por isso √© "First Fit")
    return allocation, waste  # Retorna a lista de aloca√ß√µes e os desperd√≠cios


# Fun√ß√£o que implementa o algoritmo Best Fit
def best_fit(memory_blocks, processes):
    allocation = [-1] * len(processes)
    waste = [0] * len(processes)

    for i, process in enumerate(processes):
        best_idx = -1  # √çndice do menor bloco suficiente (ainda n√£o definido)
        for j, block in enumerate(memory_blocks):
            if block >= process:  # Se o bloco √© suficiente
                if best_idx == -1 or memory_blocks[j] < memory_blocks[best_idx]:
                    best_idx = j  # Atualiza o melhor √≠ndice se for o menor at√© agora
        if best_idx != -1:
            allocation[i] = best_idx
            waste[i] = memory_blocks[best_idx] - process
            memory_blocks[best_idx] -= process
    return allocation, waste


# Fun√ß√£o que implementa o algoritmo Worst Fit
def worst_fit(memory_blocks, processes):
    allocation = [-1] * len(processes)
    waste = [0] * len(processes)

    for i, process in enumerate(processes):
        worst_idx = -1  # √çndice do maior bloco suficiente
        for j, block in enumerate(memory_blocks):
            if block >= process:
                if worst_idx == -1 or memory_blocks[j] > memory_blocks[worst_idx]:
                    worst_idx = j  # Atualiza o √≠ndice se este bloco for maior
        if worst_idx != -1:
            allocation[i] = worst_idx
            waste[i] = memory_blocks[worst_idx] - process
            memory_blocks[worst_idx] -= process
    return allocation, waste


# Fun√ß√£o que imprime os resultados com explica√ß√£o detalhada
def print_allocation(processes, allocation, waste, memory_blocks_after, strategy_name, original_total_mem):
    print(f"\n--- {strategy_name} ---")  # Nome do algoritmo
    total_waste = 0  # Inicializa o total de desperd√≠cio
    print("\nVisualiza√ß√£o de Aloca√ß√£o:\n")

    for i, alloc in enumerate(allocation):  # Para cada processo
        if alloc != -1:
            # Visualiza√ß√£o textual: blocos verdes (processo) e cinzas (desperd√≠cio)
            print(f"Processo {i} ({processes[i]}) ‚Üí Bloco {alloc} | " +
                  f"{'‚ñà' * (processes[i] // 10)} ({processes[i]}) + " +
                  f"{'.' * (waste[i] // 10)} ({waste[i]} desperd√≠cio)")
            total_waste += waste[i]  # Soma o desperd√≠cio individual ao total
        else:
            print(f"Processo {i} ({processes[i]}) ‚Üí N√£o alocado")  # Caso n√£o tenha sido alocado

    # Soma os tamanhos dos processos alocados (ignora os que ficaram de fora)
    used_mem = sum(processes[i] for i in range(len(processes)) if allocation[i] != -1)

    # Mem√≥ria economizada = total original - usada - desperd√≠cio
    unused_mem = original_total_mem - used_mem - total_waste

    # Impress√µes explicativas das contas
    print(f"\nüîç Total de desperd√≠cio (fragmenta√ß√£o interna): {total_waste} unidades (soma de {waste})")
    print(f"üì¶ Mem√≥ria usada pelos processos: {used_mem} unidades (soma dos processos alocados)")
    print("\nüí° Mem√≥ria economizada (mem√≥ria totalmente livre):")
    print(f"   = Mem√≥ria total dispon√≠vel - Mem√≥ria usada - Desperd√≠cio")
    print(f"   = {original_total_mem} - {used_mem} - {total_waste}")
    print(f"   = {unused_mem} unidades livres\n")


# Fun√ß√£o principal que prepara os dados e executa os algoritmos
def main():
    print("üß† Simulador de Gerenciamento de Mem√≥ria\n")

    # Lista com blocos de mem√≥ria dispon√≠veis no sistema
    memory_blocks = [130, 130, 130, 130, 130]

    # Lista com os tamanhos dos processos que precisam de aloca√ß√£o
    processes = [120, 125, 124, 110, 119]

    # Calcula a mem√≥ria total original (antes de qualquer aloca√ß√£o)
    original_total_mem = sum(memory_blocks)

    # Exibe os dados iniciais
    print("üìä Blocos de Mem√≥ria:", memory_blocks)
    print("‚öôÔ∏è Tamanhos dos Processos:", processes)

    # --- FIRST FIT ---
    mem_copy_ff = copy.deepcopy(memory_blocks)  # C√≥pia para n√£o modificar o original
    ff_alloc, ff_waste = first_fit(mem_copy_ff, processes)
    print_allocation(processes, ff_alloc, ff_waste, mem_copy_ff, "First Fit", original_total_mem)

    # --- BEST FIT ---
    mem_copy_bf = copy.deepcopy(memory_blocks)
    bf_alloc, bf_waste = best_fit(mem_copy_bf, processes)
    print_allocation(processes, bf_alloc, bf_waste, mem_copy_bf, "Best Fit", original_total_mem)

    # --- WORST FIT ---
    mem_copy_wf = copy.deepcopy(memory_blocks)
    wf_alloc, wf_waste = worst_fit(mem_copy_wf, processes)
    print_allocation(processes, wf_alloc, wf_waste, mem_copy_wf, "Worst Fit", original_total_mem)


# Execu√ß√£o do programa
if __name__ == "__main__":
    main()


üü¢ Cen√°rio 1 ‚Äì B√°sico e sim√©trico
Para treinar o funcionamento dos algoritmos com resultados previs√≠veis.

* Blocos de mem√≥ria: [100, 500, 200, 300, 600]
* Processos: [212, 417, 112, 426]

‚úÖ Objetivo did√°tico:
* Comparar como cada algoritmo aloca os mesmos processos.
* Mostrar que First Fit nem sempre √© o mais eficiente.

First fit: √© mais r√°pido, uma vez que encerra a busca por mem√≥ria dispon√≠vel assim que encontra espa√ßo suficiente para o processo. Por√©m, por esse mesmo motivo (encaixar no primeiro espa√ßo dispon√≠vel), pode levar mais tempo para executar v√°rios processos, uma vez que, ao alocar um bloco de mem√≥ria, possivelmente haver√° desperd√≠cio de mem√≥ria, restando v√°rios fragmentos menores de mem√≥ria inutilizada. Com isso, eventualmente, pode n√£o haver espa√ßo para alocar alguns processos, precisando de m√©todos para contornar essa situa√ß√£o. √â bom para casos onde o tempo √© um fator crucial na execu√ß√£o nos processos.

Best fit: √© mais lento que o first fit, porque passa por todos os blocos dispon√≠veis para verificar qual bloco que, ao ser alocado, ter√° o menor desperd√≠cio. Por esse motivo, a chance de algum processo n√£o ser alocado √© menor. Por√©m, por conseguir alocar todos mais facilmente, as unidades de mem√≥ria dispon√≠veis s√£o menores. Caso a quantidade de mem√≥ria dispon√≠vel/reservada seja importante para o programa/sistema, o best fit pode n√£o ser a melhor escolha.

Worst fit: busca pelo bloco de mem√≥ria que, ao ser alocado, resultar√° num maior desperd√≠cio (mais unidades de mem√≥ria livres). Consequentemente, o desperd√≠cio de mem√≥ria √© maior. No final, a mem√≥ria fica fragmentada em blocos menores que os iniciais e pode ficar mais dif√≠cil de encaixar alguns processos que sejam mais custosos (tanto que um processo n√£o foi alocado). Por outro lado, a quantidade de mem√≥ria usada √© menor. Logo, no final, haver√° uma quantidade razo√°vel de mem√≥ria livre (ainda que menor que ao usar o first fit).

üü° Cen√°rio 2 ‚Äì Blocos maiores que processos
Baixa fragmenta√ß√£o, mas m√∫ltiplas escolhas poss√≠veis.

* Blocos de mem√≥ria: [700, 600, 500, 400, 300]
* Processos: [120, 200, 230, 300, 250]

‚úÖ Objetivo did√°tico:
* Ver que Best Fit usa melhor os blocos.
* Worst Fit pode deixar muitos blocos inutiliz√°veis.

First fit: todos os processos foram alocados, por√©m o desperd√≠cio foi grande e n√£o sobraram unidades de mem√≥ria (do contr√°rio, o desperd√≠cio foi maior que a quantidade de mem√≥ria usada).

Best fit: o desperd√≠cio foi pequeno, logo sobraram muitas unidade de mem√≥ria.

Worst fit: tamb√©m houve um gasto enorme de mem√≥ria. O desperd√≠cio foi maior que o uso de mem√≥ria.

üü† Cen√°rio 3 ‚Äì Fragmenta√ß√£o causada pela ordem dos blocos
Todos os processos cabem, mas a ordem muda tudo.

* Blocos de mem√≥ria: [300, 200, 100, 400, 500]
* Processos: [100, 300, 400]

‚úÖ Objetivo did√°tico:
* Mudar a ordem dos blocos e comparar os resultados.
* Analisar o impacto da ordem em First Fit.

First fit: o desperd√≠cio foi relativamente grande, dada a quantidade de mem√≥ria total usada e a quantidade de mem√≥ria dispon√≠vel. Ao colocar os blocos em ordem crescente, o desperd√≠cio foi menor. Mesmo assim, depende da ordem dos blocos.

Best fit: n√£o houve desperd√≠cio de mem√≥ria, sobrou bastante unidades de mem√≥ria.

Worst fit: mesmo caso do first fit. Dependendo da ordem dos blocos, o desperd√≠cio pode ser maior. Em um √∫nico caso o desperd√≠cio foi 0.

üîµ Cen√°rio 4 ‚Äì Processo grande s√≥ cabe em 1 bloco
Mostra como fragmenta√ß√£o pode impedir grandes processos mesmo com bastante mem√≥ria livre.

* Blocos de mem√≥ria: [150, 200, 300, 350, 400]
* Processos: [80, 120, 90, 500]

‚úÖ Objetivo did√°tico:
* Observar qual algoritmo √© mais propenso a deixar o processo de 500 sem espa√ßo.
* Introdu√ß√£o ao problema de fragmenta√ß√£o externa.

First fit: o desperd√≠cio foi maior que o uso de mem√≥ria, mas ainda assim a quantidade restante foi grande. Por isso, ao reordenar os blocos livres, √© poss√≠vel encaixar o processo de 500.

Best fit: assim como o first fit, o desperd√≠cio foi maior que o uso de mem√≥ria e a quantidade restante foi grande. Tamb√©m √© poss√≠vel reordenar os blocos dispon√≠veis para encaixar o processo de 500.

Worst fit: o desperd√≠cio foi muito maior que a mem√≥ria usada. Al√©m disso, com a fragmenta√ß√£o da mem√≥ria, as unidades livres n√£o s√£o suficientes para encaixar o processo de 500.

üî¥ Cen√°rio 5 ‚Äì Mem√≥ria limitada, processos pequenos
Sistema embarcado ou restrito.

* Blocos de mem√≥ria: [128, 64, 256, 128]
* Processos: [64, 32, 128, 96, 256]

‚úÖ Objetivo did√°tico:
* Mostrar a dificuldade de alocar v√°rios processos em blocos pequenos.
* Comparar qual algoritmo consegue alocar mais.

First fit: n√£o conseguiu alocar todos os processos e n√£o sobrou espa√ßo para reordenar e alocar mais unidades de mem√≥ria.

Best fit: embora o desperd√≠cio tenha sido pequeno, toda a mem√≥ria foi usada (tr√™s processos ocuparam todo o espa√ßo de um bloco). Logo, sobraram -96 unidades livres.

Worst fit: nem todos os processos foram alocados. Al√©m disso, o desperd√≠cio foi muito grande em alguns blocos. No final, o desperd√≠cio foi maior que a mem√≥ria usada e muito pr√≥xima da mem√≥ria total dispon√≠vel, o que resultou em muitas unidades livres negativas.

‚ö´ Cen√°rio 6 ‚Äì Alta fragmenta√ß√£o esperada
For√ßar os algoritmos a desperdi√ßar mem√≥ria.

* Blocos de mem√≥ria: [130, 130, 130, 130, 130]
* Processos: [120, 125, 124, 110, 119]

‚úÖ Objetivo did√°tico:
* Observar que todos os algoritmos deixam pequenos fragmentos inutilizados.
* Introdu√ß√£o ao conceito de desperd√≠cio cumulativo.

Todos os algoritmos resultaram em 0 unidades dispon√≠veis. Todos consumiram a mesma quantidade de mem√≥ria e o desperd√≠cio foi o mesmo.

Para cada cen√°rio:

* Testar os tr√™s algoritmos.
* Medir:
    * Quais processos foram alocados?
    * Qual foi o total de mem√≥ria usada?
    * Qual foi o desperd√≠cio total (fragmenta√ß√£o interna)?
    * Qual foi a mem√≥ria totalmente livre ao final?
* Concluir:
    * Qual algoritmo foi mais eficiente e por qu√™?
    * Qual desperdi√ßou mais mem√≥ria?

O Best Fit foi o mais eficiente porque, ao procurar o menor bloco poss√≠vel que ainda caiba o processo, ele minimiza o desperd√≠cio e fragmenta√ß√£o, mesmo que seja mais lento na busca.

O Worst Fit tende a deixar grandes peda√ßos de mem√≥ria inutiliz√°veis, promovendo alta fragmenta√ß√£o externa e inefici√™ncia, especialmente quando h√° muitos processos ou a mem√≥ria √© limitada.

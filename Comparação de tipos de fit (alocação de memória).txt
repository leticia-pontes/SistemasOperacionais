First fit: é mais rápido, uma vez que encerra a busca por memória disponível assim que encontra espaço suficiente para o processo. Porém, por esse mesmo motivo (encaixar no primeiro espaço disponível), pode levar mais tempo para executar vários processos, uma vez que, ao alocar um bloco de memória, possivelmente haverá desperdício de memória, restando vários fragmentos menores de memória inutilizada. Com isso, eventualmente, pode não haver espaço para alocar alguns processos, precisando de métodos para contornar essa situação. É bom para casos onde o tempo é um fator crucial na execução nos processos.

Best fit: é mais lento que o first fit, porque passa por todos os blocos disponíveis para verificar qual bloco que, ao ser alocado, terá o menor desperdício. Por esse motivo, a chance de algum processo não ser alocado é menor. Porém, por conseguir alocar todos mais facilmente, as unidades de memória disponíveis são menores. Caso a quantidade de memória disponível/reservada seja importante para o programa/sistema, o best fit pode não ser a melhor escolha.

Worst fit: tenta alocar o processo no maior bloco de memória disponível, ou seja, aquele que deixará o maior espaço livre restante após a alocação. A ideia por trás dessa estratégia é evitar a fragmentação externa, já que grandes blocos restantes podem ser mais úteis futuramente do que pequenos fragmentos. No entanto, o worst fit tende a gerar muita fragmentação interna, pois frequentemente grandes blocos são subdivididos mesmo quando processos pequenos são alocados. Além disso, é o mais demorado dos três métodos, pois precisa analisar todos os blocos para encontrar o maior. Pode ser útil em situações em que se deseja preservar blocos médios ou pequenos para processos futuros de menor porte, mas, na prática, raramente oferece desempenho superior ao first fit ou best fit.
